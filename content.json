[{"title":"this","date":"2017-04-14T08:21:48.000Z","path":"2017/04/14/this/","text":"##his 我们主要研究的是函数里的this * 1元素绑定事件，当事件触发的时候，this就是事件触发时的元素 * 2this是谁跟函数在哪里定义和在哪里执行没关系，就看调用函数的主体是谁，其实也就是看函数执行的时候&quot;.&quot;前面是谁,this就是谁 * 3自执行函数的this是window，无论在哪都是window * 4在构造函数中的this是当前实例 * 5call和apply都会强制改变this。 * 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445console.log(this); /*document.getElementById(&apos;div1&apos;).onclick = function ()&#123; console.log(this); &#125;*/ function fn()&#123; //这是函数的定义 console.log(this); &#125; //window.fn(); //这才是函数的执行，点前面是window.所以this就是window /* var obj = &#123; fn : fn &#125;*/ //obj.fn(); // var fo = &#123; x : function ()&#123; console.log(this); fn(); //this ==&gt; window &#125; &#125; fo.x(); //fo*/ var haha = &#123; y : (function ()&#123; console.log(this); return function ()&#123; console.log(this); &#125; &#125;)() &#125; haha.y(); ~function ()&#123; console.log(this); fn(); &#125;()*/ // 一个自定义类 构造函数 function FE()&#123; //console.log(this); this.x = &apos;ga&apos;; &#125; FE();//当成一个函数去运行 var ff = new FE(); //就把FE当成一个类去运行，而fe就是FE的一个实例 console.log(ff);","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js设计模式","date":"2017-04-14T08:08:51.000Z","path":"2017/04/14/原型/","text":"##原型 prototype * 1当我们声明了一个函数(构造函数,类)的时候，天生自带了一个prototype的属性。并且这个prototype的值也是一个对象类型的。这个对象类型值也有一个天生自带的属性叫constructor并且这个属性的值是函数(构造函数，类)本身 * 2这个类的实例也会有一个叫做__proto__的天生自带的属性,并且这个属性的值也是一个对象类型的。这个值是这个实例所属类的原型. * 3每一个引用类型都有一个天生自带的属性叫__proto__,所以说我们的prototype的值也有天生自带一个__proto__的属性。并且这个属性的值也是一个对象类型，一直到我们的基类Object * 4通过类的原型添加的属性和方法都是公有的，每个实例都会自带 * 5一个实例的方法在运行的时候，如果这个方法是自己私有的，那么就直接用，如果不是私有的，那么通过__proto__去所属类的原型上去查找，如果还没有就通过原型的__proto__一直查到基类的Object.如果还没有报错，如果有就直接用了。我们把这种通过__proto__查找的机制叫做原型链. * 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748*原型模式* function FE()&#123; this.x = 100; this.y = 200; &#125; FE.prototype.code = function ()&#123; //在FE的原型上添加了一个code属性，属性值是一个函数 //console.log(&apos;我是通过原型添加的&apos;) //console.log(this.x); &#125; //console.dir(FE); //var fe1 = new FE(); //fe1.code(); //说明成功添加了一个code的属性 //console.dir(fe1); var fe2 = new FE(); //fe2.code(); //fe2.xfe2.__proto__.codeing = function ()&#123; //alert(&apos;gaga&apos;);&#125;//fe2.codeing();//?????var fe3 = new FE();//fe3.codeing();//fe3.codeing = function ()&#123; //alert(&apos;fe3&apos;);//&#125;//console.log(fe2.codeing()); //??//console.dir(fe3);//fe3.__proto__.__proto__ == Object.prototype for(var attr in fe3)&#123; if(fe3.hasOwnProperty(attr))&#123; console.log(attr); &#125; &#125;*批量设置共有的属性和方法 function Girl()&#123; &#125; Girl.prototype = &#123; //用一个新的对象把原来的原型的地址替换了 constructor : Girl, a : function ()&#123;&#125;, b : function ()&#123;&#125;, c : function ()&#123;&#125; /*push:...*/ &#125; Girl.prototype.a Girl.prototype.b Girl.prototype.c ####单例模式: 就是一个破对象， 也是命名空间模式。(namespace)是js编程中最常用的模块化（？？）开发模式,在工作过程中也会经常看到.1234567891011121314151617181920212223242526272829303132333435363738394041function Table() &#123; //用function的方式去创建一个人为的一个类 &#125; var table1 = new Table(); //用实例创建的方式，创建了一个具体化的类也就是一个shi&apos;li var person = &#123; //我自己 name : &apos;tianxi&apos;, age : 30, height : &apos;175cm&apos;, weight : &apos;90kg&apos;, code : function ()&#123; //我有一个写代码的功能 &#125;, change : function ()&#123; &#125;, utils:&#123; &#125; &#125; var person2 = &#123; name : &apos;youcheng&apos;, height : &apos;180cm&apos;, wirteJs : function ()&#123; //这个方法是youcheng的，但是我不一定会 &#125;, change: function ()&#123; &#125; &#125; var Tx = &#123; change: function ()&#123;&#125; &#125; var zy = &#123; change : function ()&#123;&#125; &#125; //person.code(); //person2.writeJs(); console.log(person); ####工厂模式: 解决不能批量生产，它是一个破函数,把实现相同功能的属性拿出来放到一个函数里了，我们把这种方式也叫函数的封装。但是工厂模式不能解决实例识别的问题 ####面向对象：函数的封装，继承（子类继承父类的方法和属性等,祖传），多态:包括重载和重写，js中只有重写，但是却可以模拟重载.1234567891011121314151617181920function table()&#123; //我们的车床 var obj = &#123;&#125;; obj.width = 200; obj.height = 300; obj.fn = function ()&#123; //桌子能干啥，我也不知道 &#125; return obj; &#125; var tab1 = table(); //相当于车床通电运行一次就给我造一个桌子,是不是要给我留下东西呀 tab1.fn2 = function ()&#123; //烧火吧 &#125; var tab2 = table(); // //new table(); (&#123;&#125;).toString == &apos;[object Object]&apos;; //分别代表的是数据类型和所属的类 [].toString == &quot;&quot;; //[1,2,3].toString() = &apos;1,2,3&apos; //在定义数组的toString方法的时候被重写了","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"作用域的销毁和内存释放","date":"2017-04-14T07:55:00.000Z","path":"2017/04/14/作用域的销毁和内存释放/","text":"作用域的销毁和内存释放* 作用域销毁和内存释放问题 * 1如果让一个堆内存释放掉那么就让这个堆内存没有被其他变量引用，如果函数在执行的后，函数体内的某一部分被函数体外占用，那么我们运行后返回的堆内存和运行时产生的作用域（栈内存）都不会被释放掉.如果没有被占用，浏览器会主动回收内存空间 * 2 函数运行的时候，在函数体内定义的匿名函数赋值给函数体外的dom元素的事件属性，内存也不会被释放掉 * 3 函数运行之后留下来的返回值是一个函数，立刻又被执行一次，这样是不会被立刻释放掉的。 12 var obj = &#123;name:&apos;tianxi&apos;,age:30&#125;; //这个对象的堆内存地址只要被obj这个变量引用，这个堆内存就不会被释放;obj = null; //把一个空的指针赋值给obj，这样obj以前的堆内存就会被释放掉 1234567891011 var num = 12;function fn()&#123; //fn在预解释的时候已经赋值一个堆内存 //var num = 100; return function ()&#123; //仍然是一个引用类型，堆内存地址xxxfff111 var x; console.log(num); &#125;&#125;var f = fn(); //是把fn运行留下来的结果赋值给f(并且我们发现return出来是一个函数,相当于把函数的引用地址赋值给f变量)，函数运行： 1 形参赋值 2 预解释 3 代码执行 //函数运行的时候开辟一个新的私有作用域f(); 12 var oDiv = document.getElementById(&apos;div1&apos;); //通过dom获取，是一个dom对象console.dir(oDiv);// 12345678(function (j)&#123; oDiv[&apos;onclick&apos;] = function ()&#123; console.log(&apos;点我a&apos;); // //oli[j] //this &#125;&#125;)(i); 123456 function test()&#123; return function ()&#123; console.log(1); &#125;&#125;test()();","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"作用域的销毁和内存释放","date":"2017-04-14T07:55:00.000Z","path":"2017/04/14/基本数据类型跟引用数据类型/","text":"作用域的销毁和内存释放* 作用域销毁和内存释放问题 * 1如果让一个堆内存释放掉那么就让这个堆内存没有被其他变量引用，如果函数在执行的后，函数体内的某一部分被函数体外占用，那么我们运行后返回的堆内存和运行时产生的作用域（栈内存）都不会被释放掉.如果没有被占用，浏览器会主动回收内存空间 * 2 函数运行的时候，在函数体内定义的匿名函数赋值给函数体外的dom元素的事件属性，内存也不会被释放掉 * 3 函数运行之后留下来的返回值是一个函数，立刻又被执行一次，这样是不会被立刻释放掉的。 12 var obj = &#123;name:&apos;tianxi&apos;,age:30&#125;; //这个对象的堆内存地址只要被obj这个变量引用，这个堆内存就不会被释放;obj = null; //把一个空的指针赋值给obj，这样obj以前的堆内存就会被释放掉 1234567891011 var num = 12;function fn()&#123; //fn在预解释的时候已经赋值一个堆内存 //var num = 100; return function ()&#123; //仍然是一个引用类型，堆内存地址xxxfff111 var x; console.log(num); &#125;&#125;var f = fn(); //是把fn运行留下来的结果赋值给f(并且我们发现return出来是一个函数,相当于把函数的引用地址赋值给f变量)，函数运行： 1 形参赋值 2 预解释 3 代码执行 //函数运行的时候开辟一个新的私有作用域f(); 12 var oDiv = document.getElementById(&apos;div1&apos;); //通过dom获取，是一个dom对象console.dir(oDiv);// 12345678(function (j)&#123; oDiv[&apos;onclick&apos;] = function ()&#123; console.log(&apos;点我a&apos;); // //oli[j] //this &#125;&#125;)(i); 123456 function test()&#123; return function ()&#123; console.log(1); &#125;&#125;test()();","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"预解释","date":"2017-04-14T06:37:59.000Z","path":"2017/04/14/预解释/","text":"预解释 当浏览器开始解析js代码的时候，首先看当前运行环境(作用域)内带var和function，带var的变量会提前声明(预解释)但是不会赋值，带function的会提前声明并赋值。带var变量提前声明的时候并不会被赋值，但是有一个默认的nudefined值。当代码执行过后才会赋值。 堆栈内存： 代码运行的环境也是作用域是栈内存，而用来保存值的内存是堆内存.基本数据类型都存在栈内存里 预解释只看等号左面的变量，并不会看你的值是什么 我们的预解释只发生在当前作用域 案例一在全局作用域下，加var和不加var的区别 console.log(num);undefined console.log(obj); console.log(sum); var num = 12; //赋值 console.log(num); //12 var obj = {&apos;name&apos;: &apos;tianxi&apos;, age: 30}; //对象类型 console.log(obj);*/ console.log(haha);//?? var a = function () {};//预解释只看等号左面的变量，并不会看你的值是什么 /*function sum(num1, num2) { //当代码执行到这的时候，声明和赋值都已经结束，直接跳过 function haha() { }; //我们的预解释只发生在当前作用域 var total = 0; total = num1 + num2; } #### 在全局作用域下，加var和不加var的区别 1 是否被提前声明 2 不加var那么就是一个赋值过程，相当于给window添加了一个属性并且赋值 当函数在运行的时候就会产生一个私有的作用域，并且这个作用域内的变量也是私有变量。并且这个私有变量在外访问不到，我们把这种函数运行的时候产生的私有作用域里的私有变量不受外界干扰的这种机制叫做闭包 函数的运行： 1 如果有形参是形参赋值 2 预解释 3 代码逐行执行 ..区别私有变量还是全局变量：函数运行的时候，函数体内如有带var就是私有变量，如果是形参也可以理解是一个私有变量。代码在执行的时候，首先查找当前运行环境内(作用域，栈)的私有变量，如果有直接用，如果没有去上一级作用域去查找，如果有就拿来用，如果没有一直查找到顶级的window全局作用域，如果没有就报错了 not defined,我们把这种查找机制叫做作用域链 //console.log(total); //undefined //total = 0; // //console.log(window.total); // /*function sum(num1, num2) { //num1 = 10,num2 = 10 console.log(total); //undefined total = num1 + num2; console.log(total); //30 return function (){ console.log(&apos;ff&apos;); } } sum(10, 20); var f = sum(19,40); // f(); console.log(total); //0*/ //function b(x){} b(); //console.log(total); //undefined,0,30,30 , //0,30,30 /* function fn(){ total = 100; //赋值的过程，直接赋值给window // var total = 100; //这个是私有变量跟外面没半毛钱关系 } fn(); console.log(total);*/ var num = 12; function fn(){ var num = 100; return function (){ var x; console.log(num); } } var f = fn(); //100 f(); // x的变量才会被预解释 函数运行运行时候上一级作用域只和在哪里定义有关系 //12,100,undefined Error /*var obj = {name:&apos;haha&apos;,age:7}; console.log(&apos;name&apos; in obj);*/ 预解释的时候 * 无论条件是否成立，都会预解释 * 预解释的时候带var关键字之看等号左面 * 在全局作用域下的自执行函数不被预解释,预解释只发生在当前作用域 * return下面的代码仍然会被预解释,但是return出来的值即使你是一个函数也不会被预解释 1 无论条件是否成立，都会预解释 console.log(total); //undefined if(&apos;total&apos; in window){ var total = 6; } console.log(total); //6,undefined. 2 预解释的时候带var关键字之看等号左面 //a(); var a = function (){ alert(); } 3 自执行函数不被预解释 !function (){ var b = 0; }() 4 return下面的代码仍然会被预解释,但是return出来的值即使你是一个函数也不会被预解释 function fn(){ console.log(num); //??undefined return function (){ console.log(num); } alert(); var num = 9; } fn(); foo(); function foo(){ console.log(1); } foo(); var foo = &apos;haha&apos;; //代码执行到这的时候，我们原来的函数引用地址已经被破坏，并且把foo赋值一个字符串 foo(); //相当于让一个字符串去执行，不是函数所以报foo is not function function foo(){ console.log(2); } foo(); //undefined,1,unKonwn,unKnown","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/技术/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]